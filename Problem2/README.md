Number 2
1.	For Problem 2, we are given an array of integer and we want to find the minimum sum of a falling path through the given array. We can use the solutions in this problem to solve sub-problems that later solve bigger instances of it. Beginning by letting dp[i][j] be the minimum weight of the current falling path starting at that position in the first row until reaching the bottom. We are resetting the initial values of the given input A[][]. Therefore, coming up with dp[i][j] = A[i][j] + Math.min([I+1,j-1], dp[i+1,j], dp[i+1][j+1]). The answer being the minimum value of the current position. We continue to iterate and store the minimum value in dp. 
2.	The storing of sub-problems is happening in the original A[][]. We are resetting the values of A[][] to be the values of dp[][]. After doing so, we create a temporary variable that will store the minimum value at the new matrix at position [0][i] and return it.
3.	I identified the problem by first reading it and understanding what is going on. In this case, we are given a square array of integers A, and we want to find the minimum sum of the falling path through A. I defined the problem by understanding what is being asked of me and what I need to solve. I examined possible solutions by doing test cases (Duke 7, Step 1). For example in this problem, if we get an input of [[1,2,3],[4,5,6],[7,8,9]], the output will be 12 because the falling path with the smallest sum is [1,4,7], equaling 12. Test cases always help me understand the problem better and it helped me work on a solution by writing down what I did as well (Duke 7, Step 2). I then generalized that the only parameter being taken in was an integer 2D array (Duke 7, Step 3). I acted on the best solutions by trying to find the pattern of recursion in the problem and testing it by hand before coding (Duke 7, Step 4). After coming up with the solution, I started to code the problem (Duke 7, Step 5). I did have to do several testing to make sure that my code was working perfectly as well as debugging (Duke 7, Step 6 & 7). I learned from my results by really understanding dynamic programming and why it is being done. I understood that it is a way of “memorizing” inputs that can be later accessed to get the final result of a problem without having to compute it again. 
