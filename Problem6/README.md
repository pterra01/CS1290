Number 6
1.	For Problem 6, we are given n number of pairs of numbers. In every pair, the first number is always smaller than the second number. The catch of this problem is that we have pairs (c,d) and (a,b) but b always has to be less than c and that defines a chain of pairs. Therefore, we can use dynamic programming to “memorize” the values like we did in Problem 1. We have two values i and j, so we check that i is less than j and that pairs at position [i][1] is less than pairs that position [j][0]. If it is we extend the chain and have the answer store/ memorized in int[] dp = Math.max(dp[j], dp[i] +1). 
2.	For this problem, the 1D array dp is what is used to store the solutions. We later go through the 1D array to find and int x that is greater than a variable set to 0 and set that variable equal to x returning that variable which will give us the total number of the longest chain. Gathering the data from dp which was our dynamic programming solution storage. 
3.	I identified the problem by first reading it and understanding what is going on. In this case, we are given n number of pairs of numbers. I defined the problem by understanding what is being asked of me and what I need to solve. In this case to return the longest chain. I examined possible solutions by doing test cases (Duke 7, Step 1).For example, in this case if we are given an input of [[1,2],[2,3],[3,4]], the output will be 2 because the longest chain if [1,2] -> [3,4]. Test cases always help me understand the problem better and it helped me work on a solution by writing down what I did as well (Duke 7, Step 2). I then generalized that the only parameter being taken in was an integer 2D array (Duke 7, Step 3). I acted on the best solutions by trying to find the pattern of recursion in the problem and testing it by hand before coding (Duke 7, Step 4). After coming up with the solution, I started to code the problem (Duke 7, Step 5). I did have to do several testing to make sure that my code was working perfectly as well as debugging (Duke 7, Step 6 & 7). I learned from my results by really understanding dynamic programming and why it is being done. I understood that it is a way of “memorizing” inputs that can be later accessed to get the final result of a problem without having to compute it again. 
