Number 1
1.	For Problem 1, we have two players Alex and Lee who are playing a game with a pile of stones. There are an even number of piles arranged in a row, and each pile has a positive integer of number of stones piles[i]. Whoever ends the game with the most stones. Therefore, since Alex always goes first, he will always have the most stones as long as he picks the most stones from either side of the row. If Alex picks the first value of the row, then he can’t pick the second because that is an option for Lee. His next option is the third value and so on. We must return True if Alex wins, which is every time. Unless, there is a tie. This problem reminded me of the House Robber problem and helped me understand why it is dynamic programming. We have piles[i] and piles[j]. Those being both ends of the row. If Alex or Lee pick piles[i], the result equation will be piles[i] – dp[i+1][j]. “dp” is the 2D array created to store solutions. If Alex or Lee pick piles[j], the result equation will be piles[j] – dp[i][j-1]. So we get the dynamic programming equation of dp[i][j] = Math.max(piles[i] – dp[i+1][j], piles[j] – dp[i][j-1]). Math.max storing the maximum value from either equation on the indicated position of the matrix. 
2.	For this problem, the 2D array dp is what is used to store solutions. This is helpful because in recursion we tend to solve problems over and over, when dynamic programming “memorizes” that value and it can be later used instead of computing it again. dp[i][j] starts with a small subarray and then it is used to calculate the big subarray. This all depending on what side of the row each player’s pick.
3.	I identified the problem by first reading it and understanding what is going on. In this case, they are playing a game. I defined the problem by understanding what is being asked of me and what I need to solve. In this case to return true if Alex wins. I examined possible solutions by doing test cases (Duke 7, Step 1). For example, given an input array of [5,3,4,5]. The output will be True because Alex does win. Test cases always help me understand the problem better and it helped me work on a solution by writing down what I did as well (Duke 7, Step 2). I then generalized that the only parameter being taken in was an integer array (Duke 7, Step 3). I acted on the best solutions by trying to find the pattern of recursion in the problem and testing it by hand before coding (Duke 7, Step 4). After coming up with the solution, I started to code the problem (Duke 7, Step 5). I did have to do several testing to make sure that my code was working perfectly as well as debugging (Duke 7, Step 6 & 7). I learned from my results by really understanding dynamic programming and why it is being done. I understood that it is a way of “memorizing” inputs that can be later accessed to get the final result of a problem without having to compute it again. 
