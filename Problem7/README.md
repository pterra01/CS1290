Number 7
1.	For Problem 7, we are given an integer n and we need to break it into the sum of at least two positive integers and maximize the product of those two integers returning the max product we get. For this problem, we use dynamic programming/ memorization. Since we are computing the same operation for different values, we store it in a new 1D array dp. dp[i] denotes the maximum product breaking i. Our dynamic equation being dp[i] = Math.max(dp[i], j*dp[i-j]). As you can see, the multiplication is happening in the equation. We get the max of that and will store that in dp at position i and of all the possible ways of breaking i into (i-1, 1), (i-2,2).. and so on.
2.	For this problem, the 1D array dp is what is used to store the solutions. The equation dp[i] = Math.max(dp[i], j*dp[i-j]) is what is going to store that value at the corresponding i position of dp starting at 2 because of the base case dp[1] = 0. We later use this to solve the global problem by later accessing the value at dp[n], n being the input integer. That position will have the max value it computed from the dp[i] = Math.max(dp[i], j*dp[i-j]) equation. 
3. I identified the problem by first reading it and understanding what is going on. In this case, we are given a positive integer n. I defined the problem by understanding what is being asked of me and what I need to solve. In this case to return the maximum product. I examined possible solutions by doing test cases (Duke 7, Step 1). For example in this problem, if we are given an input of 10, the output will be 36 because 10 = 3+3+4, and 3*3*4 = 36. Test cases always help me understand the problem better and it helped me work on a solution by writing down what I did as well (Duke 7, Step 2). I then generalized that the only parameter being taken in was an integer n (Duke 7, Step 3). I acted on the best solutions by trying to find the pattern of recursion in the problem and testing it by hand before coding (Duke 7, Step 4). After coming up with the solution, I started to code the problem (Duke 7, Step 5). I did have to do several testing to make sure that my code was working perfectly as well as debugging (Duke 7, Step 6 & 7). I learned from my results by really understanding dynamic programming and why it is being done. I understood that it is a way of “memorizing” inputs that can be later accessed to get the final result of a problem without having to compute it again. 
