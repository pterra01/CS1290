Number 9
1.	For Problem 9, we are given a positive integer n, and we need to find the least number of perfect square numbers that sum to n. We will also do some dynamic programming in this problem because we need to keep track of that values to later access them to get the final result instead of computing again. The minimum number of perfect squares that add up to n is the minimum of the current value at that position i, therefore having the equation dp[i – j*j] + 1. J*J is a perfect square. Therefore that equation stores how many perfect squares are needed in addition to the current perfect square(j*j) to get the minimum position i. Coming up with the dp equation of dp[i] = Math.min(dp[i-j*j]+1, dp[i]). 
2.	The storing of sub-problems is happening in the 1D array dp that is created to have the length of size integer n(given) +1. We create this to store that minimum value and later use it to return the minimum value at position of n(given). 
3.	I identified the problem by first reading it and understanding what is going on. In this case, we are given a positive integer n and we need to find the least number of perfect square numbers that sum to n. I defined the problem by understanding what is being asked of me and what I need to solve. I examined possible solutions by doing test cases (Duke 7, Step 1). For example in this problem, if we are given an input of n =12, the output will be 3 because 12 = 4 + 4 + 4 equaling three 4s. 4 being a perfect square number. Test cases always help me understand the problem better and it helped me work on a solution by writing down what I did as well (Duke 7, Step 2). I then generalized that the only parameter being taken in was an integer n (Duke 7, Step 3). I acted on the best solutions by trying to find the pattern of recursion in the problem and testing it by hand before coding (Duke 7, Step 4). After coming up with the solution, I started to code the problem (Duke 7, Step 5). I did have to do several testing to make sure that my code was working perfectly as well as debugging (Duke 7, Step 6 & 7). I learned from my results by really understanding dynamic programming and why it is being done. I understood that it is a way of “memorizing” inputs that can be later accessed to get the final result of a problem without having to compute it again. 
